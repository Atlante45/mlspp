#include "tree_math.h"

#include "common.h"
#include "tls_syntax.h"
#include <catch.hpp>
#include <vector>

using namespace mls;

// Test vectors from:
// https://github.com/mlswg/mls-implementations/blob/master/test_vectors/treemath.md
//
// Except for:
// * level
// * node_width
// * parent_step
// * dirpath
// * copath

namespace answers {

const uint32_t size = 255;

const bytes root_data = from_hex(
  "000003F800000000000000010000000300000003000000070000000700000007000000070000"
  "000F0000000F0000000F0000000F0000000F0000000F0000000F0000000F0000001F0000001F"
  "0000001F0000001F0000001F0000001F0000001F0000001F0000001F0000001F0000001F0000"
  "001F0000001F0000001F0000001F0000001F0000003F0000003F0000003F0000003F0000003F"
  "0000003F0000003F0000003F0000003F0000003F0000003F0000003F0000003F0000003F0000"
  "003F0000003F0000003F0000003F0000003F0000003F0000003F0000003F0000003F0000003F"
  "0000003F0000003F0000003F0000003F0000003F0000003F0000003F0000003F0000007F0000"
  "007F0000007F0000007F0000007F0000007F0000007F0000007F0000007F0000007F0000007F"
  "0000007F0000007F0000007F0000007F0000007F0000007F0000007F0000007F0000007F0000"
  "007F0000007F0000007F0000007F0000007F0000007F0000007F0000007F0000007F0000007F"
  "0000007F0000007F0000007F0000007F0000007F0000007F0000007F0000007F0000007F0000"
  "007F0000007F0000007F0000007F0000007F0000007F0000007F0000007F0000007F0000007F"
  "0000007F0000007F0000007F0000007F0000007F0000007F0000007F0000007F0000007F0000"
  "007F0000007F0000007F0000007F0000007F0000007F000000FF000000FF000000FF000000FF"
  "000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF0000"
  "00FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF"
  "000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF0000"
  "00FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF"
  "000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF0000"
  "00FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF"
  "000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF0000"
  "00FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF"
  "000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF0000"
  "00FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF"
  "000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF0000"
  "00FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF"
  "000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF");

const bytes left_data = from_hex(
  "000003F800000000000000000000000200000001000000040000000400000006000000030000"
  "0008000000080000000A000000090000000C0000000C0000000E000000070000001000000010"
  "00000012000000110000001400000014000000160000001300000018000000180000001A0000"
  "00190000001C0000001C0000001E0000000F0000002000000020000000220000002100000024"
  "00000024000000260000002300000028000000280000002A000000290000002C0000002C0000"
  "002E000000270000003000000030000000320000003100000034000000340000003600000033"
  "00000038000000380000003A000000390000003C0000003C0000003E0000001F000000400000"
  "004000000042000000410000004400000044000000460000004300000048000000480000004A"
  "000000490000004C0000004C0000004E00000047000000500000005000000052000000510000"
  "005400000054000000560000005300000058000000580000005A000000590000005C0000005C"
  "0000005E0000004F000000600000006000000062000000610000006400000064000000660000"
  "006300000068000000680000006A000000690000006C0000006C0000006E0000006700000070"
  "0000007000000072000000710000007400000074000000760000007300000078000000780000"
  "007A000000790000007C0000007C0000007E0000003F00000080000000800000008200000081"
  "0000008400000084000000860000008300000088000000880000008A000000890000008C0000"
  "008C0000008E0000008700000090000000900000009200000091000000940000009400000096"
  "0000009300000098000000980000009A000000990000009C0000009C0000009E0000008F0000"
  "00A0000000A0000000A2000000A1000000A4000000A4000000A6000000A3000000A8000000A8"
  "000000AA000000A9000000AC000000AC000000AE000000A7000000B0000000B0000000B20000"
  "00B1000000B4000000B4000000B6000000B3000000B8000000B8000000BA000000B9000000BC"
  "000000BC000000BE0000009F000000C0000000C0000000C2000000C1000000C4000000C40000"
  "00C6000000C3000000C8000000C8000000CA000000C9000000CC000000CC000000CE000000C7"
  "000000D0000000D0000000D2000000D1000000D4000000D4000000D6000000D3000000D80000"
  "00D8000000DA000000D9000000DC000000DC000000DE000000CF000000E0000000E0000000E2"
  "000000E1000000E4000000E4000000E6000000E3000000E8000000E8000000EA000000E90000"
  "00EC000000EC000000EE000000E7000000F0000000F0000000F2000000F1000000F4000000F4"
  "000000F6000000F3000000F8000000F8000000FA000000F9000000FC000000FC");

const bytes right_data = from_hex(
  "000003F8000000000000000200000002000000050000000400000006000000060000000B0000"
  "00080000000A0000000A0000000D0000000C0000000E0000000E000000170000001000000012"
  "00000012000000150000001400000016000000160000001B000000180000001A0000001A0000"
  "001D0000001C0000001E0000001E0000002F0000002000000022000000220000002500000024"
  "00000026000000260000002B000000280000002A0000002A0000002D0000002C0000002E0000"
  "002E00000037000000300000003200000032000000350000003400000036000000360000003B"
  "000000380000003A0000003A0000003D0000003C0000003E0000003E0000005F000000400000"
  "004200000042000000450000004400000046000000460000004B000000480000004A0000004A"
  "0000004D0000004C0000004E0000004E00000057000000500000005200000052000000550000"
  "005400000056000000560000005B000000580000005A0000005A0000005D0000005C0000005E"
  "0000005E0000006F000000600000006200000062000000650000006400000066000000660000"
  "006B000000680000006A0000006A0000006D0000006C0000006E0000006E0000007700000070"
  "0000007200000072000000750000007400000076000000760000007B000000780000007A0000"
  "007A0000007D0000007C0000007E0000007E000000BF00000080000000820000008200000085"
  "0000008400000086000000860000008B000000880000008A0000008A0000008D0000008C0000"
  "008E0000008E0000009700000090000000920000009200000095000000940000009600000096"
  "0000009B000000980000009A0000009A0000009D0000009C0000009E0000009E000000AF0000"
  "00A0000000A2000000A2000000A5000000A4000000A6000000A6000000AB000000A8000000AA"
  "000000AA000000AD000000AC000000AE000000AE000000B7000000B0000000B2000000B20000"
  "00B5000000B4000000B6000000B6000000BB000000B8000000BA000000BA000000BD000000BC"
  "000000BE000000BE000000DF000000C0000000C2000000C2000000C5000000C4000000C60000"
  "00C6000000CB000000C8000000CA000000CA000000CD000000CC000000CE000000CE000000D7"
  "000000D0000000D2000000D2000000D5000000D4000000D6000000D6000000DB000000D80000"
  "00DA000000DA000000DD000000DC000000DE000000DE000000EF000000E0000000E2000000E2"
  "000000E5000000E4000000E6000000E6000000EB000000E8000000EA000000EA000000ED0000"
  "00EC000000EE000000EE000000F7000000F0000000F2000000F2000000F5000000F4000000F6"
  "000000F6000000FB000000F8000000FA000000FA000000FD000000FC000000FE");

const bytes parent_data = from_hex(
  "000003F8000000010000000300000001000000070000000500000003000000050000000F0000"
  "00090000000B00000009000000070000000D0000000B0000000D0000001F0000001100000013"
  "00000011000000170000001500000013000000150000000F000000190000001B000000190000"
  "00170000001D0000001B0000001D0000003F0000002100000023000000210000002700000025"
  "00000023000000250000002F000000290000002B00000029000000270000002D0000002B0000"
  "002D0000001F000000310000003300000031000000370000003500000033000000350000002F"
  "000000390000003B00000039000000370000003D0000003B0000003D0000007F000000410000"
  "004300000041000000470000004500000043000000450000004F000000490000004B00000049"
  "000000470000004D0000004B0000004D0000005F000000510000005300000051000000570000"
  "005500000053000000550000004F000000590000005B00000059000000570000005D0000005B"
  "0000005D0000003F000000610000006300000061000000670000006500000063000000650000"
  "006F000000690000006B00000069000000670000006D0000006B0000006D0000005F00000071"
  "0000007300000071000000770000007500000073000000750000006F000000790000007B0000"
  "0079000000770000007D0000007B0000007D000000FF00000081000000830000008100000087"
  "0000008500000083000000850000008F000000890000008B00000089000000870000008D0000"
  "008B0000008D0000009F00000091000000930000009100000097000000950000009300000095"
  "0000008F000000990000009B00000099000000970000009D0000009B0000009D000000BF0000"
  "00A1000000A3000000A1000000A7000000A5000000A3000000A5000000AF000000A9000000AB"
  "000000A9000000A7000000AD000000AB000000AD0000009F000000B1000000B3000000B10000"
  "00B7000000B5000000B3000000B5000000AF000000B9000000BB000000B9000000B7000000BD"
  "000000BB000000BD0000007F000000C1000000C3000000C1000000C7000000C5000000C30000"
  "00C5000000CF000000C9000000CB000000C9000000C7000000CD000000CB000000CD000000DF"
  "000000D1000000D3000000D1000000D7000000D5000000D3000000D5000000CF000000D90000"
  "00DB000000D9000000D7000000DD000000DB000000DD000000BF000000E1000000E3000000E1"
  "000000E7000000E5000000E3000000E5000000EF000000E9000000EB000000E9000000E70000"
  "00ED000000EB000000ED000000DF000000F1000000F3000000F1000000F7000000F5000000F3"
  "000000F5000000EF000000F9000000FB000000F9000000F7000000FD000000FB");

const bytes sibling_data = from_hex(
  "000003F80000000200000005000000000000000B000000060000000100000004000000170000"
  "000A0000000D00000008000000030000000E000000090000000C0000002F0000001200000015"
  "000000100000001B000000160000001100000014000000070000001A0000001D000000180000"
  "00130000001E000000190000001C0000005F0000002200000025000000200000002B00000026"
  "0000002100000024000000370000002A0000002D00000028000000230000002E000000290000"
  "002C0000000F0000003200000035000000300000003B00000036000000310000003400000027"
  "0000003A0000003D00000038000000330000003E000000390000003C000000BF000000420000"
  "0045000000400000004B000000460000004100000044000000570000004A0000004D00000048"
  "000000430000004E000000490000004C0000006F0000005200000055000000500000005B0000"
  "00560000005100000054000000470000005A0000005D00000058000000530000005E00000059"
  "0000005C0000001F0000006200000065000000600000006B0000006600000061000000640000"
  "00770000006A0000006D00000068000000630000006E000000690000006C0000004F00000072"
  "00000075000000700000007B000000760000007100000074000000670000007A0000007D0000"
  "0078000000730000007E000000790000007C0000017F0000008200000085000000800000008B"
  "000000860000008100000084000000970000008A0000008D00000088000000830000008E0000"
  "00890000008C000000AF0000009200000095000000900000009B000000960000009100000094"
  "000000870000009A0000009D00000098000000930000009E000000990000009C000000DF0000"
  "00A2000000A5000000A0000000AB000000A6000000A1000000A4000000B7000000AA000000AD"
  "000000A8000000A3000000AE000000A9000000AC0000008F000000B2000000B5000000B00000"
  "00BB000000B6000000B1000000B4000000A7000000BA000000BD000000B8000000B3000000BE"
  "000000B9000000BC0000003F000000C2000000C5000000C0000000CB000000C6000000C10000"
  "00C4000000D7000000CA000000CD000000C8000000C3000000CE000000C9000000CC000000EF"
  "000000D2000000D5000000D0000000DB000000D6000000D1000000D4000000C7000000DA0000"
  "00DD000000D8000000D3000000DE000000D9000000DC0000009F000000E2000000E5000000E0"
  "000000EB000000E6000000E1000000E4000000F7000000EA000000ED000000E8000000E30000"
  "00EE000000E9000000EC000000CF000000F2000000F5000000F0000000FB000000F6000000F1"
  "000000F4000000E7000000FA000000FD000000F8000000F3000000FE000000F9");

} // namespace answers

template<typename F>
void
vector_test(F function, bytes answer_data)
{
  tls::vector<uint32_t, 4> vals;
  tls::unmarshal(answer_data, vals);
  for (uint32_t i = 0; i < vals.size(); ++i) {
    REQUIRE(function(i) == vals[i]);
  }
}

template<typename F>
auto
size_scope(F function)
{
  return [=](uint32_t x) -> auto { return function(x, answers::size); };
}

TEST_CASE("Tree math functions match expected outputs", "[tree-math]")
{
  SECTION("root")
  {
    tls::vector<uint32_t, 4> vals;
    tls::unmarshal(answers::root_data, vals);
    for (uint32_t n = 1; n < vals.size() - 1; n += 1) {
      REQUIRE(tree_math::root(n) == vals[n - 1]);
    }
  }

  SECTION("left") { vector_test(tree_math::left, answers::left_data); }

  SECTION("right")
  {
    vector_test(size_scope(tree_math::right), answers::right_data);
  }

  SECTION("parent")
  {
    vector_test(size_scope(tree_math::parent), answers::parent_data);
  }

  SECTION("sibling")
  {
    vector_test(size_scope(tree_math::sibling), answers::sibling_data);
  }
}
