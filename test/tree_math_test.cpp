#include "tree_math.h"
#include <catch.hpp>
#include <vector>

using namespace mls;

// Precomputed answers for the tree on eleven elements:
//
//                                               X
//                       X
//           X                       X                       X
//     X           X           X           X           X
//  X     X     X     X     X     X     X     X     X     X     X
// 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14

namespace answers {

const uint32_t n = 0x0b;

const std::vector<uint32_t> root{ 0x00, 0x01, 0x03, 0x03, 0x07, 0x07,
                                  0x07, 0x07, 0x0f, 0x0f, 0x0f };
const std::vector<uint32_t> index{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
                                   0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d,
                                   0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14 };

const std::vector<uint32_t> left{ 0x00, 0x00, 0x02, 0x01, 0x04, 0x04, 0x06,
                                  0x03, 0x08, 0x08, 0x0a, 0x09, 0x0c, 0x0c,
                                  0x0e, 0x07, 0x10, 0x10, 0x12, 0x11, 0x14 };

const std::vector<uint32_t> right{ 0x00, 0x02, 0x02, 0x05, 0x04, 0x06, 0x06,
                                   0x0b, 0x08, 0x0a, 0x0a, 0x0d, 0x0c, 0x0e,
                                   0x0e, 0x13, 0x10, 0x12, 0x12, 0x14, 0x14 };

const std::vector<uint32_t> parent{ 0x01, 0x03, 0x01, 0x07, 0x05, 0x03, 0x05,
                                    0x0f, 0x09, 0x0b, 0x09, 0x07, 0x0d, 0x0b,
                                    0x0d, 0x0f, 0x11, 0x13, 0x11, 0x0f, 0x13 };

const std::vector<uint32_t> sibling{ 0x02, 0x05, 0x00, 0x0b, 0x06, 0x01, 0x04,
                                     0x13, 0x0a, 0x0d, 0x08, 0x03, 0x0e, 0x09,
                                     0x0c, 0x0f, 0x12, 0x14, 0x10, 0x07, 0x11 };

const std::vector<std::vector<uint32_t>> frontier{
  { 0x00 },       { 0x01 },       { 0x01, 0x04 },       { 0x03 },
  { 0x03, 0x08 }, { 0x03, 0x09 }, { 0x03, 0x09, 0x0c }, { 0x07 },
  { 0x07, 0x10 }, { 0x07, 0x11 }, { 0x07, 0x11, 0x14 },
};

const std::vector<std::vector<uint32_t>> dirpath{
  { 0x07, 0x03, 0x01 },
  { 0x07, 0x03 },
  { 0x07, 0x03, 0x01 },
  { 0x07 },
  { 0x07, 0x03, 0x05 },
  { 0x07, 0x03 },
  { 0x07, 0x03, 0x05 },
  {},
  { 0x07, 0x0b, 0x09 },
  { 0x07, 0x0b },
  { 0x07, 0x0b, 0x09 },
  { 0x07 },
  { 0x07, 0x0b, 0x0d },
  { 0x07, 0x0b },
  { 0x07, 0x0b, 0x0d },
  {},
  { 0x13, 0x11 },
  { 0x13 },
  { 0x13, 0x11 },
  {},
  { 0x13 },
};

const std::vector<std::vector<uint32_t>> copath{
  { 0x13, 0x0b, 0x05, 0x02 },
  { 0x13, 0x0b, 0x05 },
  { 0x13, 0x0b, 0x05, 0x00 },
  { 0x13, 0x0b },
  { 0x13, 0x0b, 0x01, 0x06 },
  { 0x13, 0x0b, 0x01 },
  { 0x13, 0x0b, 0x01, 0x04 },
  { 0x13 },
  { 0x13, 0x03, 0x0d, 0x0a },
  { 0x13, 0x03, 0x0d },
  { 0x13, 0x03, 0x0d, 0x08 },
  { 0x13, 0x03 },
  { 0x13, 0x03, 0x09, 0x0e },
  { 0x13, 0x03, 0x09 },
  { 0x13, 0x03, 0x09, 0x0c },
  {},
  { 0x07, 0x14, 0x12 },
  { 0x07, 0x14 },
  { 0x07, 0x14, 0x10 },
  { 0x07 },
  { 0x07, 0x11 },
};

const std::vector<uint32_t> leaves{ 0x00, 0x02, 0x04, 0x06, 0x08, 0x0a,
                                    0x0c, 0x0e, 0x10, 0x12, 0x14 };

} // namespace answers

template<typename F, typename A>
void
vector_test(F function, std::vector<A> answers)
{
  for (const uint32_t& i : answers::index) {
    REQUIRE(function(i) == answers[i]);
  }
}

template<typename F>
auto
size_scope(F function)
{
  return [=](uint32_t x) -> auto { return function(x, answers::n); };
}

TEST_CASE("Tree math functions match expected outputs", "[tree-math]")
{
  SECTION("root")
  {
    for (uint32_t n = 1; n < answers::n; n += 1) {
      REQUIRE(tree_math::root(n) == answers::root[n - 1]);
    }
  }

  SECTION("left") { vector_test(tree_math::left, answers::left); }

  SECTION("right")
  {
    vector_test(size_scope(tree_math::right), answers::right);
  }

  SECTION("parent")
  {
    vector_test(size_scope(tree_math::parent), answers::parent);
  }

  SECTION("sibling")
  {
    vector_test(size_scope(tree_math::sibling), answers::sibling);
  }

  SECTION("frontier")
  {
    for (uint32_t n = 1; n < answers::n; n += 1) {
      REQUIRE(tree_math::frontier(n) == answers::frontier[n - 1]);
    }
  }

  SECTION("dirpath")
  {
    vector_test(size_scope(tree_math::dirpath), answers::dirpath);
  }

  SECTION("copath")
  {
    vector_test(size_scope(tree_math::copath), answers::copath);
  }

  SECTION("leaves")
  {
    REQUIRE(tree_math::leaves(answers::n) == answers::leaves);
  }
}
